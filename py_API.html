

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Frankenstein Python API &mdash; frank 1.2.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=590429e0"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="Taking a Hankel transform, and generating mock data with frank" href="tutorials/mock_data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            frank
              <img src="_static/prom_photo.jpg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.2.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Using the code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html"> Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html"> Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html"> Tutorials</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ui.adsabs.harvard.edu/search/q=citations(doi%3A10.1093%2Fmnras%2Fstaa1365)%20&amp;sort=date%20desc%2C%20bibcode%20desc&amp;p_=0"> Papers citing frank</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Under the hood</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"> API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#geometry-classes">Geometry classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#frank.geometry.FixedGeometry"><code class="docutils literal notranslate"><span class="pre">FixedGeometry</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#frank.geometry.FitGeometryGaussian"><code class="docutils literal notranslate"><span class="pre">FitGeometryGaussian</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#frank.geometry.FitGeometryFourierBessel"><code class="docutils literal notranslate"><span class="pre">FitGeometryFourierBessel</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#frank.geometry.SourceGeometry"><code class="docutils literal notranslate"><span class="pre">SourceGeometry</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.geometry.SourceGeometry.apply_correction"><code class="docutils literal notranslate"><span class="pre">SourceGeometry.apply_correction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.geometry.SourceGeometry.deproject"><code class="docutils literal notranslate"><span class="pre">SourceGeometry.deproject()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.geometry.SourceGeometry.fit"><code class="docutils literal notranslate"><span class="pre">SourceGeometry.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.geometry.SourceGeometry.reproject"><code class="docutils literal notranslate"><span class="pre">SourceGeometry.reproject()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.geometry.SourceGeometry.undo_correction"><code class="docutils literal notranslate"><span class="pre">SourceGeometry.undo_correction()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fitting-classes">Fitting classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#frank.radial_fitters.FrankFitter"><code class="docutils literal notranslate"><span class="pre">FrankFitter</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.MAP_solution"><code class="docutils literal notranslate"><span class="pre">FrankFitter.MAP_solution</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.MAP_spectrum"><code class="docutils literal notranslate"><span class="pre">FrankFitter.MAP_spectrum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.MAP_spectrum_covariance"><code class="docutils literal notranslate"><span class="pre">FrankFitter.MAP_spectrum_covariance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.Qmax"><code class="docutils literal notranslate"><span class="pre">FrankFitter.Qmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.Rmax"><code class="docutils literal notranslate"><span class="pre">FrankFitter.Rmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.fit"><code class="docutils literal notranslate"><span class="pre">FrankFitter.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.geometry"><code class="docutils literal notranslate"><span class="pre">FrankFitter.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.q"><code class="docutils literal notranslate"><span class="pre">FrankFitter.q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.r"><code class="docutils literal notranslate"><span class="pre">FrankFitter.r</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankFitter.size"><code class="docutils literal notranslate"><span class="pre">FrankFitter.size</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.Qmax"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.Qmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.Rmax"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.Rmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.geometry"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.predict"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.predict_deprojected"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.predict_deprojected()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.q"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.r"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.r</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit.size"><code class="docutils literal notranslate"><span class="pre">FrankRadialFit.size</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.MAP"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.MAP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.Qmax"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.Qmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.Rmax"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.Rmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.covariance"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.covariance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.geometry"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.log_likelihood"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.log_likelihood()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.mean"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.mean</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.power_spectrum"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.power_spectrum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.predict"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.predict_deprojected"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.predict_deprojected()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.q"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.r"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.r</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.size"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankGaussianFit.solve_non_negative"><code class="docutils literal notranslate"><span class="pre">FrankGaussianFit.solve_non_negative()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.MAP"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.MAP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.Qmax"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.Qmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.Rmax"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.Rmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.covariance"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.covariance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.geometry"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.log_likelihood"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.log_likelihood()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.power_spectrum"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.power_spectrum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.predict"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.predict_deprojected"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.predict_deprojected()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.q"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.r"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.r</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.radial_fitters.FrankLogNormalFit.size"><code class="docutils literal notranslate"><span class="pre">FrankLogNormalFit.size</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.MAP_solution"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.MAP_solution</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.MAP_spectrum"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.MAP_spectrum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.MAP_spectrum_covariance"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.MAP_spectrum_covariance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.Qmax"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.Qmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.Rmax"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.Rmax</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.fit"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.geometry"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.q"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.q</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.r"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.r</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.debris_fitters.FrankDebrisFitter.size"><code class="docutils literal notranslate"><span class="pre">FrankDebrisFitter.size</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utility-functions-and-classes">Utility functions and classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hankel-transform">Hankel transform</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.hankel.DiscreteHankelTransform"><code class="docutils literal notranslate"><span class="pre">DiscreteHankelTransform</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.generic_dht"><code class="docutils literal notranslate"><span class="pre">generic_dht()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.get_collocation_points"><code class="docutils literal notranslate"><span class="pre">get_collocation_points()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unit-conversion">Unit conversion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.arcsec_baseline"><code class="docutils literal notranslate"><span class="pre">arcsec_baseline()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.radius_convert"><code class="docutils literal notranslate"><span class="pre">radius_convert()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.jy_convert"><code class="docutils literal notranslate"><span class="pre">jy_convert()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-alteration">Data alteration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.normalize_uv"><code class="docutils literal notranslate"><span class="pre">normalize_uv()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.cut_data_by_baseline"><code class="docutils literal notranslate"><span class="pre">cut_data_by_baseline()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visibility-binning-and-weights-estimation">Visibility binning and weights estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.UVDataBinner"><code class="docutils literal notranslate"><span class="pre">UVDataBinner</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.estimate_weights"><code class="docutils literal notranslate"><span class="pre">estimate_weights()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imaging">Imaging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.sweep_profile"><code class="docutils literal notranslate"><span class="pre">sweep_profile()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.make_image"><code class="docutils literal notranslate"><span class="pre">make_image()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.convolve_profile"><code class="docutils literal notranslate"><span class="pre">convolve_profile()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mock-data-routines">Mock data routines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.add_vis_noise"><code class="docutils literal notranslate"><span class="pre">add_vis_noise()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.make_mock_data"><code class="docutils literal notranslate"><span class="pre">make_mock_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#statistical-analysis">Statistical analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frank.utilities.draw_bootstrap_sample"><code class="docutils literal notranslate"><span class="pre">draw_bootstrap_sample()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html"> Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/discsim/frank/blob/master/HISTORY.rst"> Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/discsim/frank"> Github</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/discsim/frank/issues"> Submit an issue</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">frank</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The Frankenstein Python API</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-frankenstein-python-api">
<h1>The Frankenstein Python API<a class="headerlink" href="#the-frankenstein-python-api" title="Link to this heading"></a></h1>
<section id="geometry-classes">
<h2>Geometry classes<a class="headerlink" href="#geometry-classes" title="Link to this heading"></a></h2>
<p>Given a set of visibilities, together these classes: <strong>(1)</strong> optionally fit for the source geometry and
<strong>(2)</strong> deproject the visibilities by the given or fitted geometry.</p>
<dl class="py class">
<dt class="sig sig-object py" id="frank.geometry.FixedGeometry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.geometry.</span></span><span class="sig-name descname"><span class="pre">FixedGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dRA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dDec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.FixedGeometry" title="Link to this definition"></a></dt>
<dd><p>Disc Geometry class using pre-determined parameters.</p>
<p>Centre and deproject the source to ensure axisymmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inc</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc inclination</p></li>
<li><p><strong>PA</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc positition angle.</p></li>
<li><p><strong>dRA</strong> (<em>float</em><em>, </em><em>default = 0</em><em>, </em><em>unit = arcsec</em>) – Phase centre offset in right ascension</p></li>
<li><p><strong>dDec</strong> (<em>float</em><em>, </em><em>default = 0</em><em>, </em><em>unit = arcsec</em>) – Phase centre offset in declination</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The phase centre offsets, dRA and dDec, refer to the distance to the source
from the phase centre.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.geometry.FitGeometryGaussian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.geometry.</span></span><span class="sig-name descname"><span class="pre">FitGeometryGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inc_pa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.FitGeometryGaussian" title="Link to this definition"></a></dt>
<dd><p>Determine the disc geometry by fitting a Gaussian in Fourier space.</p>
<p>Centre and deproject the source to ensure axisymmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inc_pa</strong> (<em>tuple =</em><em> (</em><em>inclination</em><em>, </em><em>position angle</em><em>) or </em><em>None</em><em> (</em><em>default</em><em>)</em><em>, </em><em>unit = deg</em>) – Determine whether to fit for the source’s inclination and position
angle. If inc_pa = None, the inclination and PA are fit for. Else
inc_pa should be provided as a tuple</p></li>
<li><p><strong>phase_centre</strong> (<em>tuple =</em><em> (</em><em>dRA</em><em>, </em><em>dDec</em><em>) or </em><em>None</em><em> (</em><em>default</em><em>)</em><em>, </em><em>unit = arcsec</em>) – Determine whether to fit for the source’s phase centre. If
phase_centre = None, the phase centre is fit for. Else the phase
centre should be provided as a tuple</p></li>
<li><p><strong>guess</strong> (<em>list</em><em> of </em><em>len</em><em>(</em><em>4</em><em>)</em><em>, </em><em>default = None</em>) – Initial guess for the source’s inclination [deg], position angle [deg],
right ascension offset [arcsec], declination offset [arcsec].</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The phase centre offsets, dRA and dDec, refer to the distance to the source
from the phase centre.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.geometry.FitGeometryFourierBessel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.geometry.</span></span><span class="sig-name descname"><span class="pre">FitGeometryFourierBessel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inc_pa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.FitGeometryFourierBessel" title="Link to this definition"></a></dt>
<dd><p>Determine the disc geometry by fitting a non-parametric brightness
profile in visibility space.</p>
<p>The best fit is obtained by finding the geometry that minimizes
the weighted chi^2 of the visibility fit.</p>
<p>The brightness profile is modelled using the FourierBesselFitter,
which is equivalent to a FrankFitter fit without the Gaussian
Process prior. For this reason, a small number of bins is
recommended for fit stability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – <dl class="simple">
<dt>Radius of support for the functions to transform, i.e.,</dt><dd><p>f(r) = 0 for R &gt;= Rmax</p>
</dd>
</dl>
</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Number of collocation points</p></li>
<li><p><strong>inc_pa</strong> (<em>tuple =</em><em> (</em><em>inclination</em><em>, </em><em>position angle</em><em>) or </em><em>None</em><em> (</em><em>default</em><em>)</em><em>, </em><em>unit = deg</em>) – Determine whether to fit for the source’s inclination and position
angle. If inc_pa = None, the inclination and PA are fit for. Else
inc_pa should be provided as a tuple</p></li>
<li><p><strong>phase_centre</strong> (<em>tuple =</em><em> (</em><em>dRA</em><em>, </em><em>dDec</em><em>) or </em><em>None</em><em> (</em><em>default</em><em>)</em><em>, </em><em>unit = arcsec</em>) – Determine whether to fit for the source’s phase centre. If
phase_centre = None, the phase centre is fit for. Else the phase
centre should be provided as a tuple</p></li>
<li><p><strong>guess</strong> (<em>list</em><em> of </em><em>len</em><em>(</em><em>4</em><em>)</em><em>, </em><em>default = None</em>) – Initial guess for the source’s inclination [deg], position angle [deg],
right ascension offset [arcsec], and declination offset [arcsec]</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Determines whether to print the iteration progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.geometry.SourceGeometry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.geometry.</span></span><span class="sig-name descname"><span class="pre">SourceGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dRA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dDec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry" title="Link to this definition"></a></dt>
<dd><p>Base class for geometry corrections.</p>
<p>Centre and deproject the source to ensure axisymmetry</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inc</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Inclination of the disc</p></li>
<li><p><strong>PA</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Position angle of the disc</p></li>
<li><p><strong>dRA</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – Phase centre offset in right ascension.</p></li>
<li><p><strong>dDec</strong> (<em>float</em><em>, </em><em>units = arcsec</em>) – Phase centre offset in declination.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The phase centre offsets, dRA and dDec, refer to the distance to the source
from the phase centre.</p>
<dl class="py method">
<dt class="sig sig-object py" id="frank.geometry.SourceGeometry.apply_correction">
<span class="sig-name descname"><span class="pre">apply_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use3D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.apply_correction" title="Link to this definition"></a></dt>
<dd><p>Correct the phase centre and deproject the visibilities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>V</strong> (<em>array</em><em> of </em><em>real</em><em>, </em><em>size = N</em><em>, </em><em>units = Jy</em>) – Complex visibilites</p></li>
<li><p><strong>use3D</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, also return the 3rd compoent of the
de-projected visibilities, wp.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>up</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected u-points of the visibilities</p></li>
<li><p><strong>vp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected v-points of the visibilities</p></li>
<li><p><strong>wp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – [Optional] Corrected w-points of the visibilities</p></li>
<li><p><strong>Vp</strong> (<em>array of real, size = N, unit = Jy</em>) – Corrected complex visibilites</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.geometry.SourceGeometry.deproject">
<span class="sig-name descname"><span class="pre">deproject</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use3D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.deproject" title="Link to this definition"></a></dt>
<dd><p>Convert uv-points from sky-plane to deprojected space (u,v)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>use3D</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, also return the 3rd compoent of the
de-projected visibilities, wp.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>up</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected u-points of the visibilities</p></li>
<li><p><strong>vp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected v-points of the visibilities</p></li>
<li><p><strong>wp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – [Optional] Corrected w-points of the visibilities</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.geometry.SourceGeometry.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.fit" title="Link to this definition"></a></dt>
<dd><p>Determine geometry using the provided uv-data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>V</strong> (<em>array</em><em> of </em><em>complex</em><em>, </em><em>size = N</em><em>, </em><em>unit = Jy</em>) – Complex visibilites</p></li>
<li><p><strong>weights</strong> (<em>array</em><em> of </em><em>real</em><em>, </em><em>size = N</em><em>, </em><em>unit = Jy</em>) – Weights on the visibilities</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.geometry.SourceGeometry.reproject">
<span class="sig-name descname"><span class="pre">reproject</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.reproject" title="Link to this definition"></a></dt>
<dd><p>Convert uv-points from deprojected space to sky-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>up</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected u-points of the visibilities</p></li>
<li><p><strong>vp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected v-points of the visibilities</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.geometry.SourceGeometry.undo_correction">
<span class="sig-name descname"><span class="pre">undo_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.geometry.SourceGeometry.undo_correction" title="Link to this definition"></a></dt>
<dd><p>Undo the phase centre correction and deprojection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u-points of the visibilities</p></li>
<li><p><strong>v</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – v-points of the visibilities</p></li>
<li><p><strong>V</strong> (<em>array</em><em> of </em><em>real</em><em>, </em><em>size = N</em><em>, </em><em>unit = Jy</em>) – Complex visibilites</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>up</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected u-points of the visibilities</p></li>
<li><p><strong>vp</strong> (array of real, size = N, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Corrected v-points of the visibilities</p></li>
<li><p><strong>Vp</strong> (<em>array of real, size = N, unit = Jy</em>) – Corrected complex visibilites</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="fitting-classes">
<h2>Fitting classes<a class="headerlink" href="#fitting-classes" title="Link to this heading"></a></h2>
<p>Together these classes reconstruct the 1D radial brightness profile of a source by fitting
the deprojected visibilities.</p>
<dl class="py class">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.radial_fitters.</span></span><span class="sig-name descname"><span class="pre">FrankFitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Normal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_qbounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_iteration_diagnostics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_optically_thick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence_failure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankFitter" title="Link to this definition"></a></dt>
<dd><p>Fit a Gaussian process model using the Discrete Hankel Transform of
Baddour &amp; Chouinard (2015).</p>
<p>The GP model is based upon Oppermann et al. (2013), which use a maximum
a posteriori estimate for the power spectrum as the GP prior for the
real-space coefficients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – Radius of support for the functions to transform, i.e., f(r) = 0 for
R &gt;= Rmax.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Number of collaction points</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em>) – Geometry used to deproject the visibilities before fitting</p></li>
<li><p><strong>nu</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Order of the discrete Hankel transform, given by J_nu(r)</p></li>
<li><p><strong>block_data</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Large temporary matrices are needed to set up the data. If block_data
is True, we avoid this, limiting the memory requirement to block_size
elements</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Size of the matrices if blocking is used</p></li>
<li><p><strong>alpha</strong> (<em>float &gt;= 1</em><em>, </em><em>default = 1.05</em>) – Order parameter of the inverse gamma prior for the power spectrum
coefficients</p></li>
<li><p><strong>p_0</strong> (<em>float &gt;= 0</em><em>, </em><em>default = None</em><em>, </em><em>unit=Jy^2</em>) – Scale parameter of the inverse gamma prior for the power spectrum
coefficients. If not provided p_0 = 1e-15 (method=”Normal”) or
1e-35 (method=”LogNormal”) will be used.</p></li>
<li><p><strong>weights_smooth</strong> (<em>float &gt;= 0</em><em>, </em><em>default = 1e-4</em>) – Spectral smoothness prior parameter. Zero is no smoothness prior</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em><em>, </em><em>default = 1e-3</em>) – Tolerence for convergence of the power spectrum iteration</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>default=&quot;Normal&quot;</em>) – Model used for the brightness reconstrution. This must be one of
“Normal” of “LogNormal”.</p></li>
<li><p><strong>I_scale</strong> (<em>float</em><em>, </em><em>default = 1e5</em><em>, </em><em>unit= Jy/Sr</em>) – Brightness scale. Only used in the LogNormal model. Note the
LogNormal model produces I(Rmax) =  I_scale.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>default = 2000</em>) – Maximum number of fit iterations</p></li>
<li><p><strong>check_qbounds</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to check if the first (last) collocation point is smaller
(larger) than the shortest (longest) deprojected baseline in the dataset</p></li>
<li><p><strong>store_iteration_diagnostics</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to store the power spectrum parameters and brightness profile
for each fit iteration</p></li>
<li><p><strong>assume_optically_thick</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to correct the visibility amplitudes by a factor of
1 / cos(inclination); see frank.geometry.rescale_total_flux</p></li>
<li><p><strong>scale_height</strong> (<em>function R --&gt; H</em><em>, </em><em>optional</em>) – Specifies the vertical thickness of disc as a function of radius. Both
R and H should be in arcsec. Assumes a Gaussian vertical structure.
Only works with assume_optically_thick=False</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Whether to print notification messages</p></li>
<li><p><strong>convergence_failure</strong> (<em>string</em><em>, </em><em>default = 'raise'</em>) – Decide what to do when the frank model does not converge within max_iter.
Should be one of:
‘raise’  : raise an error
‘warn’   : print a warning message and continue
‘ignore’ : Ignore the error.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>Baddour &amp; Chouinard (2015)</dt><dd><p>DOI: <a class="reference external" href="https://doi.org/10.1364/JOSAA.32.000611">https://doi.org/10.1364/JOSAA.32.000611</a></p>
</dd>
<dt>Oppermann et al. (2013)</dt><dd><p>DOI:  <a class="reference external" href="https://doi.org/10.1103/PhysRevE.87.032136">https://doi.org/10.1103/PhysRevE.87.032136</a></p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.MAP_solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP_solution</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.MAP_solution" title="Link to this definition"></a></dt>
<dd><p>Reconstruction for the maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.MAP_spectrum">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP_spectrum</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.MAP_spectrum" title="Link to this definition"></a></dt>
<dd><p>Maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.MAP_spectrum_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP_spectrum_covariance</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.MAP_spectrum_covariance" title="Link to this definition"></a></dt>
<dd><p>Covariance matrix of the maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.Qmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.Qmax" title="Link to this definition"></a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.Rmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.Rmax" title="Link to this definition"></a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.fit" title="Link to this definition"></a></dt>
<dd><p>Fit the visibilties</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (1D array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points of the visibilies</p></li>
<li><p><strong>v</strong> (1D array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points of the visibilies</p></li>
<li><p><strong>V</strong> (<em>1D array</em><em>, </em><em>unit = Jy</em>) – Visibility amplitudes at q</p></li>
<li><p><strong>weights</strong> (<em>1D array</em><em>, </em><em>optional</em><em>, </em><em>unit = J^-2</em>) – Weights of the visibilities, weight = 1 / sigma^2, where sigma is
the standard deviation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sol</strong> – Least-squares Fourier-Bessel series fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit" title="frank.radial_fitters.FrankRadialFit">FrankRadialFit</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geometry</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.geometry" title="Link to this definition"></a></dt>
<dd><p>Geometry object</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.q">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.q" title="Link to this definition"></a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.r">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">r</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.r" title="Link to this definition"></a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankFitter.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#frank.radial_fitters.FrankFitter.size" title="Link to this definition"></a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.radial_fitters.</span></span><span class="sig-name descname"><span class="pre">FrankRadialFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit" title="Link to this definition"></a></dt>
<dd><p>Base class for results of frank fits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis_map</strong> (<em>VisibilityMapping object</em>) – Mapping between image and visibility plane.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – Dictionary containing useful quantities for reproducing a fit
(such as the hyperparameters used)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.Qmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.Qmax" title="Link to this definition"></a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.Rmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.Rmax" title="Link to this definition"></a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geometry</span></span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.geometry" title="Link to this definition"></a></dt>
<dd><p>SourceGeometry object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.predict" title="Link to this definition"></a></dt>
<dd><p>Predict the visibilities in the sky-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = <span class="math notranslate nohighlight">\(I(r_k)\)</span></p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V(u,v)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span> and the position angle, inclination and phase
centre determined by the geometry object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.predict_deprojected">
<span class="sig-name descname"><span class="pre">predict_deprojected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_optically_thick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.predict_deprojected" title="Link to this definition"></a></dt>
<dd><p>Predict the visibilities in the deprojected-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (array, default = self.q, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – 1D uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy / sr</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = I(r_k)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Maximum matrix size used in the visibility calculation</p></li>
<li><p><strong>assume_optically_thick</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to correct the visibility amplitudes for the source
inclination</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V(q)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span>. The amplitude of the visibilities are reduced
according to the inclination of the source, for consistency with
<code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The visibility amplitudes are still reduced due to the projection,
for consistency with <code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.q">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.q" title="Link to this definition"></a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.r">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">r</span></span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.r" title="Link to this definition"></a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankRadialFit.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#frank.radial_fitters.FrankRadialFit.size" title="Link to this definition"></a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.radial_fitters.</span></span><span class="sig-name descname"><span class="pre">FrankGaussianFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DHT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit" title="Link to this definition"></a></dt>
<dd><p>Result of a frank fit with a Gaussian brightness model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DHT</strong> (<a class="reference internal" href="#frank.hankel.DiscreteHankelTransform" title="frank.hankel.DiscreteHankelTransform"><em>DiscreteHankelTransform</em></a>) – A DHT object with N bins that defines H(p). The DHT is used to compute
<span class="math notranslate nohighlight">\(S(p)\)</span></p></li>
<li><p><strong>fit</strong> (<em>GaussianModel object</em>) – Result of fitting with MAP power spectrum.</p></li>
<li><p><strong>info</strong> (<em>dict</em><em>, </em><em>optional</em>) – Dictionary containing useful quantities for reproducing a fit
(such as the hyperparameters used)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.MAP">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.MAP" title="Link to this definition"></a></dt>
<dd><p>Posterior maximum, unit = Jy / sr</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.Qmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.Qmax" title="Link to this definition"></a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.Rmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.Rmax" title="Link to this definition"></a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.covariance" title="Link to this definition"></a></dt>
<dd><p>Posterior covariance, unit = (Jy / sr)**2</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geometry</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.geometry" title="Link to this definition"></a></dt>
<dd><p>SourceGeometry object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.log_likelihood">
<span class="sig-name descname"><span class="pre">log_likelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.log_likelihood" title="Link to this definition"></a></dt>
<dd><p>Compute one of two types of likelihood.</p>
<p>If <span class="math notranslate nohighlight">\(I\)</span> is provided, this computes</p>
<p>Otherwise the marginalized likelihood is computed,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>I</strong> (<em>array</em><em>, </em><em>size = N</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy / sr</em>) – Intensity <span class="math notranslate nohighlight">\(I(r)\)</span> to compute the likelihood of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>log_P</strong> – Log likelihood, <span class="math notranslate nohighlight">\(\log[P(I,V|p)]\)</span> or <span class="math notranslate nohighlight">\(\log[P(V|p)]\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>The prior probability P(S) is not included.</p></li>
<li><p>The likelihoods take the form:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\log[P(I,V|p)] = \frac{1}{2} j^T I - \frac{1}{2} I^T D^{-1} I
   - \frac{1}{2} \log[\det(2 \pi S)] + H_0\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\log[P(V|p)] = \frac{1}{2} j^T D j
   + \frac{1}{2} \log[\det(D)/\det(S)] + H_0\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[H_0 = -\frac{1}{2} V^T w V + \frac{1}{2} \sum \log(w /2 \pi)\]</div>
<p>is the noise likelihood.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.mean">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mean</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.mean" title="Link to this definition"></a></dt>
<dd><p>Posterior mean, unit = Jy / sr</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.power_spectrum">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">power_spectrum</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.power_spectrum" title="Link to this definition"></a></dt>
<dd><p>Power spectrum coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.predict" title="Link to this definition"></a></dt>
<dd><p>Predict the visibilities in the sky-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = <span class="math notranslate nohighlight">\(I(r_k)\)</span></p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V(u,v)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span> and the position angle, inclination and phase
centre determined by the geometry object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.predict_deprojected">
<span class="sig-name descname"><span class="pre">predict_deprojected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_optically_thick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.predict_deprojected" title="Link to this definition"></a></dt>
<dd><p>Predict the visibilities in the deprojected-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (array, default = self.q, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – 1D uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy / sr</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = I(r_k)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Maximum matrix size used in the visibility calculation</p></li>
<li><p><strong>assume_optically_thick</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to correct the visibility amplitudes for the source
inclination</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V(q)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span>. The amplitude of the visibilities are reduced
according to the inclination of the source, for consistency with
<code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The visibility amplitudes are still reduced due to the projection,
for consistency with <code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.q">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.q" title="Link to this definition"></a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.r">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">r</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.r" title="Link to this definition"></a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.size" title="Link to this definition"></a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankGaussianFit.solve_non_negative">
<span class="sig-name descname"><span class="pre">solve_non_negative</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankGaussianFit.solve_non_negative" title="Link to this definition"></a></dt>
<dd><p>Compute the best fit solution with non-negative intensities</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.radial_fitters.</span></span><span class="sig-name descname"><span class="pre">FrankLogNormalFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DHT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit" title="Link to this definition"></a></dt>
<dd><p>Result of a frank fit with a Gaussian brightness model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>DHT</strong> (<a class="reference internal" href="#frank.hankel.DiscreteHankelTransform" title="frank.hankel.DiscreteHankelTransform"><em>DiscreteHankelTransform</em></a>) – A DHT object with N bins that defines H(p). The DHT is used to compute
<span class="math notranslate nohighlight">\(S(p)\)</span></p></li>
<li><p><strong>fit</strong> (<em>LogNormalMAPModel object</em>) – Result of fitting with MAP power spectrum.</p></li>
<li><p><strong>info</strong> (<em>dict</em><em>, </em><em>optional</em>) – Dictionary containing useful quantities for reproducing a fit
(such as the hyperparameters used)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.MAP">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.MAP" title="Link to this definition"></a></dt>
<dd><p>Posterior maximum, unit = Jy / sr</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.Qmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.Qmax" title="Link to this definition"></a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.Rmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rmax</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.Rmax" title="Link to this definition"></a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.covariance" title="Link to this definition"></a></dt>
<dd><p>Posterior covariance, unit = log[(Jy / sr)**2]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geometry</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.geometry" title="Link to this definition"></a></dt>
<dd><p>SourceGeometry object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.log_likelihood">
<span class="sig-name descname"><span class="pre">log_likelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.log_likelihood" title="Link to this definition"></a></dt>
<dd><p>Compute the likelihood,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>I</strong> (<em>array</em><em>, </em><em>size = N</em><em>, </em><em>optional</em>) – Intensity <span class="math notranslate nohighlight">\(I(r)=exp(s0*s)\)</span> to compute the likelihood of</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>log_P</strong> – Log likelihood, <span class="math notranslate nohighlight">\(\log[P(I,V|p)]\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>The prior probability P(S) is not included.</p></li>
<li><p>The likelihood takes the form:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\log[P(I,V|p)] = j^T I - \frac{1}{2} I^T D^{-1} I
   - \frac{1}{2} \log[\det(2 \pi S)] + H_0\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[H_0 = -\frac{1}{2} V^T w V + \frac{1}{2} \sum \log(w /2 \pi)\]</div>
<p>is the noise likelihood.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.power_spectrum">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">power_spectrum</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.power_spectrum" title="Link to this definition"></a></dt>
<dd><p>Power spectrum coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.predict" title="Link to this definition"></a></dt>
<dd><p>Predict the visibilities in the sky-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = <span class="math notranslate nohighlight">\(I(r_k)\)</span></p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V(u,v)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span> and the position angle, inclination and phase
centre determined by the geometry object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.predict_deprojected">
<span class="sig-name descname"><span class="pre">predict_deprojected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_optically_thick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.predict_deprojected" title="Link to this definition"></a></dt>
<dd><p>Predict the visibilities in the deprojected-plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (array, default = self.q, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – 1D uv-points to predict the visibilities at</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>unit = Jy / sr</em>) – Intensity points to predict the vibilities of. If not specified,
the mean will be used. The intensity should be specified at the
collocation points, I[k] = I(r_k)</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Geometry used to correct the visibilities for the source
inclination. If not provided, the geometry determined during the
fit will be used</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Maximum matrix size used in the visibility calculation</p></li>
<li><p><strong>assume_optically_thick</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to correct the visibility amplitudes for the source
inclination</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V(q)</strong> – Predicted visibilties of a source with a radial flux distribution
given by <span class="math notranslate nohighlight">\(I\)</span>. The amplitude of the visibilities are reduced
according to the inclination of the source, for consistency with
<code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = Jy</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The visibility amplitudes are still reduced due to the projection,
for consistency with <code class="code docutils literal notranslate"><span class="pre">uvplot</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.q">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.q" title="Link to this definition"></a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.r">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">r</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.r" title="Link to this definition"></a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.radial_fitters.FrankLogNormalFit.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#frank.radial_fitters.FrankLogNormalFit.size" title="Link to this definition"></a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.debris_fitters.</span></span><span class="sig-name descname"><span class="pre">FrankDebrisFitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Normal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_qbounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_iteration_diagnostics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence_failure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter" title="Link to this definition"></a></dt>
<dd><p>Fit a Gaussian process model using the Discrete Hankel Transform of
Baddour &amp; Chouinard (2015).</p>
<p>The brightness model is <span class="math notranslate nohighlight">\(I(R, z) = I(R) exp(-z^2/2H(R)^2)\)</span>, where
<span class="math notranslate nohighlight">\(H(R)\)</span> is the (known) scale-height.</p>
<p>The GP model is based upon Oppermann et al. (2013), which use a maximum
a posteriori estimate for the power spectrum as the GP prior for the
real-space coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – Radius of support for the functions to transform, i.e., f(r) = 0 for
R &gt;= Rmax.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Number of collaction points</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em>) – Geometry used to deproject the visibilities before fitting</p></li>
<li><p><strong>scale_height</strong> (<em>function R --&gt; H</em>) – Specifies the thickness of disc as a function of radius. Both
units should be in arcsec.</p></li>
<li><p><strong>nu</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Order of the discrete Hankel transform, given by J_nu(r)</p></li>
<li><p><strong>block_data</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Large temporary matrices are needed to set up the data. If block_data
is True, we avoid this, limiting the memory requirement to block_size
elements</p></li>
<li><p><strong>block_size</strong> (<em>int</em><em>, </em><em>default = 10**5</em>) – Size of the matrices if blocking is used</p></li>
<li><p><strong>alpha</strong> (<em>float &gt;= 1</em><em>, </em><em>default = 1.05</em>) – Order parameter of the inverse gamma prior for the power spectrum
coefficients</p></li>
<li><p><strong>p_0</strong> (<em>float &gt;= 0</em><em>, </em><em>default = None</em><em>, </em><em>unit=Jy^2</em>) – Scale parameter of the inverse gamma prior for the power spectrum
coefficients. If not provided p_0 = 1e-15 (method=”Normal”) or
1e-35 (method=”LogNormal”) will be used.</p></li>
<li><p><strong>weights_smooth</strong> (<em>float &gt;= 0</em><em>, </em><em>default = 1e-4</em>) – Spectral smoothness prior parameter. Zero is no smoothness prior</p></li>
<li><p><strong>tol</strong> (<em>float &gt; 0</em><em>, </em><em>default = 1e-3</em>) – Tolerence for convergence of the power spectrum iteration</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>default=&quot;Normal&quot;</em>) – Model used for the brightness reconstrution. This must be one of
“Normal” of “LogNormal”.</p></li>
<li><p><strong>I_scale</strong> (<em>float</em><em>, </em><em>default = 1e5</em><em>, </em><em>unit= Jy/Sr</em>) – Brightness scale. Only used in the LogNormal model. Notet the
LogNormal model produces I(Rmax) =  I_scale.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>default = 2000</em>) – Maximum number of fit iterations</p></li>
<li><p><strong>check_qbounds</strong> (<em>bool</em><em>, </em><em>default = True</em>) – Whether to check if the first (last) collocation point is smaller
(larger) than the shortest (longest) deprojected baseline in the dataset</p></li>
<li><p><strong>store_iteration_diagnostics</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to store the power spectrum parameters and brightness profile
for each fit iteration</p></li>
<li><p><strong>verbose</strong> – Whether to print notification messages</p></li>
<li><p><strong>convergence_failure</strong> (<em>string</em><em>, </em><em>default = 'raise'</em>) – Decide what to do when the frank model does not converge within max_iter.
Should be one of:
‘raise’  : raise an error
‘warn’   : print a warning message and continue
‘ignore’ : Ignore the error.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>Baddour &amp; Chouinard (2015)</dt><dd><p>DOI: <a class="reference external" href="https://doi.org/10.1364/JOSAA.32.000611">https://doi.org/10.1364/JOSAA.32.000611</a></p>
</dd>
<dt>Oppermann et al. (2013)</dt><dd><p>DOI:  <a class="reference external" href="https://doi.org/10.1103/PhysRevE.87.032136">https://doi.org/10.1103/PhysRevE.87.032136</a></p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.MAP_solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP_solution</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.MAP_solution" title="Link to this definition"></a></dt>
<dd><p>Reconstruction for the maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.MAP_spectrum">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP_spectrum</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.MAP_spectrum" title="Link to this definition"></a></dt>
<dd><p>Maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.MAP_spectrum_covariance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MAP_spectrum_covariance</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.MAP_spectrum_covariance" title="Link to this definition"></a></dt>
<dd><p>Covariance matrix of the maximum a posteriori power spectrum</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.Qmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qmax</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.Qmax" title="Link to this definition"></a></dt>
<dd><p>Maximum frequency, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.Rmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rmax</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.Rmax" title="Link to this definition"></a></dt>
<dd><p>Maximum radius, unit = arcsec</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.fit" title="Link to this definition"></a></dt>
<dd><p>Fit the visibilties</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (1D array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points of the visibilies</p></li>
<li><p><strong>v</strong> (1D array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – uv-points of the visibilies</p></li>
<li><p><strong>V</strong> (<em>1D array</em><em>, </em><em>unit = Jy</em>) – Visibility amplitudes at q</p></li>
<li><p><strong>weights</strong> (<em>1D array</em><em>, </em><em>optional</em><em>, </em><em>unit = J^-2</em>) – Weights of the visibilities, weight = 1 / sigma^2, where sigma is
the standard deviation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sol</strong> – Least-squares Fourier-Bessel series fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#frank.radial_fitters.FrankRadialFit" title="frank.radial_fitters.FrankRadialFit">FrankRadialFit</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geometry</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.geometry" title="Link to this definition"></a></dt>
<dd><p>Geometry object</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.q">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.q" title="Link to this definition"></a></dt>
<dd><p>Frequency points, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.r">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">r</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.r" title="Link to this definition"></a></dt>
<dd><p>Radius points, unit = arcsec</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.debris_fitters.FrankDebrisFitter.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#frank.debris_fitters.FrankDebrisFitter.size" title="Link to this definition"></a></dt>
<dd><p>Number of points in reconstruction</p>
</dd></dl>

</dd></dl>

</section>
<section id="utility-functions-and-classes">
<h2>Utility functions and classes<a class="headerlink" href="#utility-functions-and-classes" title="Link to this heading"></a></h2>
<p>These are some useful functions and classes for various aspects of fitting and analysis.</p>
<section id="hankel-transform">
<h3>Hankel transform<a class="headerlink" href="#hankel-transform" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.hankel.</span></span><span class="sig-name descname"><span class="pre">DiscreteHankelTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform" title="Link to this definition"></a></dt>
<dd><p>Utilities for computing the discrete Hankel transform.</p>
<p>This class provides the necessary interface to compute
a discrete version of the Hankel transform (DHT):</p>
<blockquote>
<div><p>H[f](q) = int_0^R_{max} f(r) J_nu(2*pi*q*r) * 2*pi*r dr.</p>
</div></blockquote>
<p>The DHT is based on [1].</p>
<p>Additionally this class provides coefficients of the DHT [1] transform
matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em>) – Maximum radius beyond which f(r) is zero</p></li>
<li><p><strong>N</strong> (<em>integer</em>) – Number of terms to use in the series</p></li>
<li><p><strong>nu</strong> (<em>integer</em><em>, </em><em>default = 0</em>) – Order of the Bessel function, J_nu(r)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Baddour &amp; Chouinard (2015)</dt><dd><p>DOI: <a class="reference external" href="https://doi.org/10.1364/JOSAA.32.000611">https://doi.org/10.1364/JOSAA.32.000611</a>
Note: the definition of the DHT used here differs by factors
of 2*pi.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.Qmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qmax</span></span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.Qmax" title="Link to this definition"></a></dt>
<dd><p>Maximum frequency</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.Rmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rmax</span></span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.Rmax" title="Link to this definition"></a></dt>
<dd><p>Maximum radius</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.coefficients">
<span class="sig-name descname"><span class="pre">coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.coefficients" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Coefficients of the transform matrix, defined by</dt><dd><p>H[f](q) = np.dot(Y, f)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>array</em><em> or </em><em>None</em>) – Frequency points at which to evaluate the transform. If q = None,
the points of the DHT are used. If direction=’backward’, these
points should instead be the radius points</p></li>
<li><p><strong>direction</strong> (<em>{ 'forward'</em><em>, </em><em>'backward' }</em><em>, </em><em>optional</em>) – Direction of the transform. If not supplied, the forward transform
is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Y</strong> – The transformation matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, size = (len(q), N)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.order">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">order</span></span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.order" title="Link to this definition"></a></dt>
<dd><p>Order of the Bessel function</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.q">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.q" title="Link to this definition"></a></dt>
<dd><p>Frequency points</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.r">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">r</span></span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.r" title="Link to this definition"></a></dt>
<dd><p>Radius points</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.size" title="Link to this definition"></a></dt>
<dd><p>Number of points used in the DHT</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frank.hankel.DiscreteHankelTransform.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.hankel.DiscreteHankelTransform.transform" title="Link to this definition"></a></dt>
<dd><p>Compute the Hankel transform of an array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>array</em><em>, </em><em>size = N</em>) – <dl class="simple">
<dt>Function to Hankel transform, evaluated at the collocation points:</dt><dd><p>f[k] = f(r_k) or f[k] = f(q_k)</p>
</dd>
</dl>
</p></li>
<li><p><strong>q</strong> (<em>array</em><em> or </em><em>None</em>) – The frequency points at which to evaluate the Hankel
transform. If not specified, the conjugate points of the
DHT will be used. For the backwards transform, q should be
the radius points</p></li>
<li><p><strong>direction</strong> (<em>{ 'forward'</em><em>, </em><em>'backward' }</em><em>, </em><em>optional</em>) – Direction of the transform. If not supplied, the forward
transform is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>H[f]</strong> – The Hankel transform of the array f</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, size = N or len(q) if supplied</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.generic_dht">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">generic_dht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.generic_dht" title="Link to this definition"></a></dt>
<dd><p>Compute the visibilities or brightness of a model by directly applying the
Discrete Hankel Transform.</p>
<p>The correction for inclination will also be applied, assuming an optically
thick disc. For an optically thin disc, setting inc=0 (the default) will
achieve the correct scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>arcsec</em><em>] or </em><em>[</em><em>lambda</em><em>]</em>) – Radial or spatial frequency coordinates of f(x)</p></li>
<li><p><strong>f</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>Jy / sr</em><em>] or </em><em>[</em><em>Jy</em><em>]</em>) – Amplitude values of f(x)</p></li>
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit =</em><em> [</em><em>arcsec</em><em>]</em><em>, </em><em>default=2.0</em>) – Maximum radius beyond which the real space function is zero</p></li>
<li><p><strong>N</strong> (<em>integer</em><em>, </em><em>default=500</em>) – Number of terms to use in the Fourier-Bessel series</p></li>
<li><p><strong>direction</strong> (<em>{ 'forward'</em><em>, </em><em>'backward' }</em><em>, </em><em>default='forward'</em>) – Direction of the transform. ‘forward’ is real space -&gt; Fourier space.</p></li>
<li><p><strong>grid</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>arcsec</em><em>] or </em><em>[</em><em>lambda</em><em>]</em><em>, </em><em>default=None</em>) – The radial or spatial frequency points at which to sample the DHT.
If None, the DHT collocation points will be used.</p></li>
<li><p><strong>inc</strong> (<em>float</em><em>, </em><em>unit =</em><em> [</em><em>deg</em><em>]</em><em>, </em><em>default = 0.0</em>) – Source inclination. The total flux of the transform of f(x)
will be scaled by cos(inc); this has no effect if inc=0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>grid</strong> (<em>array, size=N, unit = [arcsec] or [lambda]</em>) – Spatial frequency or radial coordinates of the Hankel transform of f(x)</p></li>
<li><p><strong>f_transform</strong> (<em>array, size=N, unit = [Jy / sr] or [Jy]</em>) – Hankel transform of f(x)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>‘x’ and ‘f’ should be sufficiently sampled to ensure an interpolation will
be accurate, otherwise ‘f_transform’ may be a poor estimate of their
transform.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.get_collocation_points">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">get_collocation_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.get_collocation_points" title="Link to this definition"></a></dt>
<dd><p>Obtain the collocation points of a discrete Hankel transform for a given
‘Rmax’ and ‘N’ (see frank.hankel.DiscreteHankelTransform)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit =</em><em> [</em><em>arcsec</em><em>]</em><em>, </em><em>default=2.0</em>) – Maximum radius beyond which the real space function is zero</p></li>
<li><p><strong>N</strong> (<em>integer</em><em>, </em><em>default=500</em>) – Number of terms to use in the Fourier-Bessel series</p></li>
<li><p><strong>direction</strong> (<em>{ 'forward'</em><em>, </em><em>'backward' }</em><em>, </em><em>default='forward'</em>) – Direction of the transform. ‘forward’ is real space -&gt; Fourier space,
returning real space radial collocation points needed for the transform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>coll_pts</strong> – The DHT collocation points in either real or Fourier space.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = [lambda] or [arcsec]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="unit-conversion">
<h3>Unit conversion<a class="headerlink" href="#unit-conversion" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.arcsec_baseline">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">arcsec_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.arcsec_baseline" title="Link to this definition"></a></dt>
<dd><p>Provide x as a radial scale [arcsec] to return the corresponding baseline
[lambda], or vice-versa</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>float</em>) – Radial scale [arcsec] or baseline [lambda]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>converted</strong> – Baseline [lambda] or radial scale [arcsec]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.radius_convert">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">radius_convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conversion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'arcsec_au'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.radius_convert" title="Link to this definition"></a></dt>
<dd><p>Provide x as a radius/radii in [arcsec] to convert to [au] (or vice-versa),
assuming a distance in [pc]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em><em> or </em><em>array</em>) – Radius or radii ([arcsec] or [au])</p></li>
<li><p><strong>dist</strong> (<em>float</em>) – Distance to source [pc]</p></li>
<li><p><strong>conversion</strong> (<em>{'arcsec_au'</em><em>, </em><em>'au_arcsec'}</em><em>, </em><em>default = 'arcsec_au'</em>) – The unit conversion to perform, e.g. ‘arcsec_au’ converts from [arcsec]
to [au]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>converted</strong> – Radius or radii ([au] or [arcsec])</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.jy_convert">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">jy_convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conversion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmaj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.jy_convert" title="Link to this definition"></a></dt>
<dd><p>Provide x as a brightness in one of the units [Jy / beam], [Jy / arcsec^2],
[Jy / sterad] to convert x to another of these units</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em>) – Brightness in one of: [Jy / beam], [Jy / arcsec^2], [Jy / sterad]</p></li>
<li><p><strong>conversion</strong> (<em>{ 'beam_sterad'</em><em>, </em><em>'beam_arcsec2'</em><em>, </em><em>'arcsec2_beam'</em><em>,</em>) – ‘arcsec2_sterad’, ‘sterad_beam’, ‘sterad_arcsec2’}
The unit conversion to perform, e.g., ‘beam_sterad’ converts
[Jy / beam] to [Jy / sterad]</p></li>
<li><p><strong>bmaj</strong> (<em>float</em><em>, </em><em>optional</em>) – Beam FWHM along the major axis [arcsec]</p></li>
<li><p><strong>bmin</strong> (<em>float</em><em>, </em><em>optional</em>) – Beam FWHM along the minor axis [arcsec]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>converted</strong> – Brightness in converted units</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="data-alteration">
<h3>Data alteration<a class="headerlink" href="#data-alteration" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.normalize_uv">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">normalize_uv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.normalize_uv" title="Link to this definition"></a></dt>
<dd><p>Normalize data u and v coordinates by the observing wavelength</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>m</em><em>]</em>) – u and v coordinates of observations</p></li>
<li><p><strong>v</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>m</em><em>]</em>) – u and v coordinates of observations</p></li>
<li><p><strong>wle</strong> (<em>float</em><em> or </em><em>array</em><em>, </em><em>unit =</em><em> [</em><em>m</em><em>]</em>) – Observing wavelength of observations. If an array, it should be the
pointwise wavelength for each (u,v) point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>u_normed, v_normed</strong> – u and v coordinates normalized by observing wavelength</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.cut_data_by_baseline">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">cut_data_by_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.cut_data_by_baseline" title="Link to this definition"></a></dt>
<dd><p>Truncate the data to be within a chosen baseline range.</p>
<p>The cut will be done in deprojected baseline space if the geometry is
provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations</p></li>
<li><p><strong>vis</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Observed visibilities (complex: real + imag * 1j)</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Weights assigned to observed visibilities, of the form
<span class="math notranslate nohighlight">\(1 / \sigma^2\)</span></p></li>
<li><p><strong>cut_range</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>length = 2</em><em>, </em><em>unit =</em><em> [</em><em>lambda</em><em>]</em>) – Lower and upper baseline bounds outside of which visibilities are
truncated</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>optional</em>) – Fitted geometry (see frank.geometry.SourceGeometry).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>u_cut, v_cut</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates in the chosen baseline range</p></li>
<li><p><strong>vis_cut</strong> (<em>array, unit = Jy</em>) – Visibilities in the chosen baseline range</p></li>
<li><p><strong>weights_cut</strong> (<em>array, unit = Jy^-2</em>) – Weights in the chosen baseline range</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="visibility-binning-and-weights-estimation">
<h3>Visibility binning and weights estimation<a class="headerlink" href="#visibility-binning-and-weights-estimation" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="frank.utilities.UVDataBinner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">UVDataBinner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.UVDataBinner" title="Link to this definition"></a></dt>
<dd><p>Average uv-data into bins of equal size.</p>
<p>Compute the weighted mean of the visibilities in each bin</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uv</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Baselines of the data to bin</p></li>
<li><p><strong>V</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Observed visibility. If complex, both the real and imaginary
components will be binned. Else only the real part will be binned.</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Weights on the visibility points</p></li>
<li><p><strong>bin_width</strong> (float, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Width of the uv-bins</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses numpy masked arrays to mask bins with no uv points.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.estimate_weights">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">estimate_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.estimate_weights" title="Link to this definition"></a></dt>
<dd><p>Estimate the weights using the variance of the binned visibilities.</p>
<p>The estimation is done assuming that the variation in each bin is dominated
by the noise. This will be true if:
1) The source is axi-symmetric,
2) The uv-points have been deprojected,
3) The bins are not too wide,
Otherwise the variance may be dominated by intrinsic variations in the
visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations (deprojected). Data will be binned
by baseline. If v is not None, np.hpot(u,v) will be used instead. Note
that if V is None the argument v will be intepreted as V instead</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations (deprojected). Data will be binned
by baseline. If v is not None, np.hpot(u,v) will be used instead. Note
that if V is None the argument v will be intepreted as V instead</p></li>
<li><p><strong>V</strong> (<em>array</em><em>, </em><em>unit = Jy</em><em>, </em><em>default = None</em>) – Observed visibility. If complex, the weights will be computed from the
average of the variance of the real and imaginary components, as in
CASA’s statwt. Otherwise the variance of the real part is used.</p></li>
<li><p><strong>nbins</strong> (<em>int</em><em>, </em><em>default = 300</em>) – Number of bins used.</p></li>
<li><p><strong>log</strong> (<em>bool</em><em>, </em><em>default = True</em>) – If True, the uv bins will be constructed in log space, otherwise linear
spaced bins will be used.</p></li>
<li><p><strong>use_median</strong> (<em>bool</em><em>, </em><em>default = False</em>) – If True all of the weights will be set to the median of the variance
estimated across the bins. Otherwise, the baseline dependent variance
will be used.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default = True</em>) – If true, the logger will record calls to this function, along with
whether the median estimate was used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>weights</strong> – Estimate of the weight for each uv point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function does not use the original weights in the estimation.</p></li>
<li><p>Bins with only one uv point do not have a variance estimate. Thus
the mean of the variance in the two adjacent bins is used instead.</p></li>
</ul>
<p class="rubric">Examples</p>
<dl class="simple">
<dt>All of the following calls will work as expected:</dt><dd><p><code class="code docutils literal notranslate"><span class="pre">estimate_weights(u,</span> <span class="pre">v,</span> <span class="pre">V)</span> <span class="pre">`</span>
<span class="pre">`estimate_weights(u,</span> <span class="pre">V)</span></code>
<code class="code docutils literal notranslate"><span class="pre">estimate_weights(u,</span> <span class="pre">V=V)</span></code></p>
</dd>
</dl>
<p>In each case the variance of V in the uv-bins is used to estimate the
weights. The first call will use q = np.hypot(u, v) in the uv-bins. The
second and third calls are equivalent to the first with u=0.</p>
</dd></dl>

</section>
<section id="imaging">
<h3>Imaging<a class="headerlink" href="#imaging" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.sweep_profile">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">sweep_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.sweep_profile" title="Link to this definition"></a></dt>
<dd><p>Sweep a 1D radial brightness profile over <span class="math notranslate nohighlight">\(2 \pi\)</span> to yield a 2D
brightness distribution. Optionally project this sweep by a supplied
geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>array</em>) – Radial coordinates at which the 1D brightness profile is defined</p></li>
<li><p><strong>I</strong> (<em>array</em>) – Brightness values at r</p></li>
<li><p><strong>project</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to project the swept profile by the supplied geom</p></li>
<li><p><strong>phase_shift</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to phase shift the projected profile by the supplied geom.
If False, the source will be centered in the image</p></li>
<li><p><strong>geom</strong> (<em>SourceGeometry object</em><em>, </em><em>default=None</em>) – Fitted geometry (see frank.geometry.SourceGeometry). Here we use
geom.inc [deg], geom.PA [deg], geom.dRA [arcsec], geom.dDec [arcsec] if
project=True</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Axis over which to interpolate the 1D profile</p></li>
<li><p><strong>xmax</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default = None</em>) – Value setting the x- and y-bounds of the image (same units as r). The
positive and negative bounds are both set to this value (modulo sign).
If not provided, these will be set to r.max()</p></li>
<li><p><strong>ymax</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default = None</em>) – Value setting the x- and y-bounds of the image (same units as r). The
positive and negative bounds are both set to this value (modulo sign).
If not provided, these will be set to r.max()</p></li>
<li><p><strong>dr</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default = None</em>) – Pixel size (same units as r). If not provided, it will be set at the
same spatial scale as r</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>I2D</strong> (<em>array, shape = (len(r), len(r))</em>) – 2D brightness distribution (projected if project=True)</p></li>
<li><p><strong>xmax</strong> (<em>float</em>) – Maximum x-value of the 2D grid</p></li>
<li><p><strong>ymax</strong> (<em>float</em>) – Maximum y-value of the 2D grid</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Sign convention: a negative geom.dRA shifts the source to the right
in the image</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.make_image">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">make_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Npix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.make_image" title="Link to this definition"></a></dt>
<dd><p>Make an image of a model fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fit</strong> (<em>FrankFitter result object</em>) – Fitted profile to make an image of</p></li>
<li><p><strong>Npix</strong> (<em>int</em><em> or </em><em>list</em>) – Number of pixels in the x-direction, or [x-,y-] direction</p></li>
<li><p><strong>xmax</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>unit=arcsec</em>) – Size of the image is [-xmax, xmax]. By default this is twice
fit.Rmax to avoid aliasing.</p></li>
<li><p><strong>ymax</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>unit=arcsec</em>) – Size of the image is [-ymax,ymax]. Defaults to xmax if ymax=None</p></li>
<li><p><strong>project</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to produce a projected image.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> (<em>array, 1D; unit=arcsec</em>) – Locations of the x-points in the image.</p></li>
<li><p><strong>y</strong> (<em>array, 1D; unit=arcsec</em>) – Locations of the y-points in the image.</p></li>
<li><p><strong>I</strong> (<em>array, 2D; unit=Jy/Sr</em>) – Image of the surface brightness.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.convolve_profile">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">convolve_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disc_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disc_pa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_beam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_per_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.convolve_profile" title="Link to this definition"></a></dt>
<dd><p>Convolve a 1D radial brightness profile with a 2D Gaussian beam, degrading
the profile’s resolution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>array</em>) – Radial coordinates at which the 1D brightness profile is defined</p></li>
<li><p><strong>I</strong> (<em>array</em>) – Brightness values at r</p></li>
<li><p><strong>disc_i</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc inclination</p></li>
<li><p><strong>disc_pa</strong> (<em>float</em><em>, </em><em>unit = deg</em>) – Disc position angle</p></li>
<li><p><strong>clean_beam</strong> (<em>dict</em>) – Dictionary with beam <code class="code docutils literal notranslate"><span class="pre">bmaj</span></code> (FWHM of beam along its major axis) [arcsec],
<code class="code docutils literal notranslate"><span class="pre">bmin</span></code> (FWHM of beam along its minor axis) [arcsec],
<code class="code docutils literal notranslate"><span class="pre">pa</span></code> (beam position angle) [deg]</p></li>
<li><p><strong>n_per_sigma</strong> (<em>int</em><em>, </em><em>default = 50</em>) – Number of points per standard deviation of the Gaussian kernel (used
for gridding)</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Axis over which to interpolate the 1D profile</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>I_smooth</strong> – Convolved brightness profile I at coordinates r</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, shape = (len(r), len(r))</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="mock-data-routines">
<h3>Mock data routines<a class="headerlink" href="#mock-data-routines" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.add_vis_noise">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">add_vis_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.add_vis_noise" title="Link to this definition"></a></dt>
<dd><p>Add Gaussian noise to visibilities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>Jy</em><em>]</em>) – Visibilities to add noise to.
Can be complex (real + imag * 1j) or purely real.</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>Jy^-2</em><em>]</em>) – Weights on the visibilities, of the form <span class="math notranslate nohighlight">\(1 / \sigma^2\)</span>.
Injected noise will be scaled proportional to <code class="code docutils literal notranslate"><span class="pre">sigma</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default = None</em>) – Number to initialize a pseudorandom number generator for the noise draws</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vis_noisy</strong> – Visibilities with added noise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, shape = vis.shape</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.make_mock_data">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">make_mock_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.make_mock_data" title="Link to this definition"></a></dt>
<dd><p>Generate mock visibilities from a provided brightness profile and (u,v)
distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>arcsec</em><em>]</em>) – Radial coordinates of I(r)</p></li>
<li><p><strong>I</strong> (<em>array</em><em>, </em><em>unit =</em><em> [</em><em>Jy / sr</em><em>]</em>) – Brightness values at r</p></li>
<li><p><strong>Rmax</strong> (<em>float</em><em>, </em><em>unit =</em><em> [</em><em>arcsec</em><em>]</em><em>, </em><em>default=2.0</em>) – Maximum radius beyond which I(r) is zero. This should be larger than the
disk size</p></li>
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations</p></li>
<li><p><strong>projection</strong> (<em>str</em><em>, </em><em>default = None</em>) – One of [None, ‘deproject’, ‘reproject’]
If None, the visibilities will be neither deprojected nor reprojected.
If ‘deproject’ or ‘reproject’, the visibilites will be accordingly
deprojected or reprojected by the supplied <code class="code docutils literal notranslate"><span class="pre">geometry</span></code> and their total
flux scaled by the inclination.</p></li>
<li><p><strong>geometry</strong> (<em>SourceGeometry object</em><em>, </em><em>default=None</em>) – Source geometry (see frank.geometry.SourceGeometry). Must be supplied
if <code class="code docutils literal notranslate"><span class="pre">projection</span></code> is ‘deproject’ or ‘reproject’.</p></li>
<li><p><strong>N</strong> (<em>integer</em><em>, </em><em>default=500</em>) – Number of terms to use in the Fourier-Bessel series</p></li>
<li><p><strong>add_noise</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to add noise to the mock visibilities</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Visibility weights, of the form <span class="math notranslate nohighlight">\(1 / \sigma^2\)</span>.
If provided, injected noise will be scaled proportional to <code class="code docutils literal notranslate"><span class="pre">sigma</span></code>.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default = None</em>) – Number to initialize a pseudorandom number generator for the noise draws</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>baselines</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Baseline coordinates of the mock visibilities. These will be equal to
np.hypot(u, v) if ‘geometry’ is None (or if its keys are all equal to 0)</p></li>
<li><p><strong>vis</strong> (<em>array, unit = Jy</em>) – Mock visibility amplitudes, including noise if ‘add_noise’ is True</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>‘r’ and ‘I’ should be sufficiently sampled to ensure an interpolation will
be accurate, otherwise ‘vis’ may be a poor estimate of their transform.</p>
</dd></dl>

</section>
<section id="statistical-analysis">
<h3>Statistical analysis<a class="headerlink" href="#statistical-analysis" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="frank.utilities.draw_bootstrap_sample">
<span class="sig-prename descclassname"><span class="pre">frank.utilities.</span></span><span class="sig-name descname"><span class="pre">draw_bootstrap_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frank.utilities.draw_bootstrap_sample" title="Link to this definition"></a></dt>
<dd><p>Obtain the sample for a bootstrap, drawing, with replacement, N samples from
a length N dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations</p></li>
<li><p><strong>v</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – u and v coordinates of observations</p></li>
<li><p><strong>vis</strong> (<em>array</em><em>, </em><em>unit = Jy</em>) – Observed visibilities (complex: real + imag * 1j)</p></li>
<li><p><strong>weights</strong> (<em>array</em><em>, </em><em>unit = Jy^-2</em>) – Weights on the visibilities, of the form
<span class="math notranslate nohighlight">\(1 / \sigma^2\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>u_boot, v_boot</strong> (array, unit = <span class="math notranslate nohighlight">\(\lambda\)</span>) – Bootstrap sampled u and v coordinates</p></li>
<li><p><strong>vis_boot</strong> (<em>array, unit = Jy</em>) – Bootstrap sampled visibilities</p></li>
<li><p><strong>weights_boot</strong> (<em>array, unit = Jy^-2</em>) – Boostrap sampled weights on the visibilities</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorials/mock_data.html" class="btn btn-neutral float-left" title="Taking a Hankel transform, and generating mock data with frank" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2024, R. Booth, J. Jennings, M. Tazzari..
      <span class="lastupdated">Last updated on 2024 Aug 22 at 16:37:41 UTC // Images: Universal Studios, NBCUniversal [Public domain].
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>